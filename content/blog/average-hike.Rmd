---
author: ""
categories: ["R"]
tags: ["dplyr", "tidyr", "purrr", "plotKML", "geosphere", "googleway"]
date: "2019-04-06"
description: "Calculating My Average Hike Using googleway and geosphere"
featured: "hiking.png"
featuredalt: "Ain't No Mountain High Enough"
featuredpath: "date"
linktitle: ""
title: "Ain't No Mountain High Enough"
type: "post"
---

I moved to Seattle at the end of 2016 and since then have done around 100 hikes (depending on your definition of 'a  hike'!). I must admit I've been abysmal at tracking any data regarding my hiking activity beyond a [Google spreadsheet](https://docs.google.com/spreadsheets/d/1Y3NdGea6yVuoDS7ewUKmuKGZouzU62FHK-aY813TafA/edit?usp=sharing), despite the ubiquity of trail tracking apps that exist.

Recently, I signed up on [AllTrails](https://www.alltrails.com/) to start collecting data on my hikes. The Pro service offers many wonderful features, including the ability to download GPX data on hikes. I was so excited by this that I decided to try to calculate my 'average hike.'

Generally speaking, people consider two main metrics in choosing a hike: distance and elevation. So what would my 'average hike' look like? Would my average hike mean average distance, average elevation, or both? Why not all three?! 

I'm structuring this article a bit differently with the results/visualizations first, but for anybody dying to see the data cleaning process, please see the [Methodology](#methodology) section below!

# I don't particularly love long hikes

My average hike is 6.4 miles - and most of them are concentrated around that distance. This makes sense as I usually day hike and need to get back at a reasonable time.


# I don't dislike high elevation hikes though


# 


# Methodology {#methodology}

## Disclaimer 

For data collection, I downloaded each trail's GPX files from AllTrails. Because these data are proprietary, I will not be showing them here. Some things to note:

* Because these are data pulled from the AllTrails website, they are not indicative of my actual hiking path (for example, Franklin Falls is a 2 mile hike in the summer, but in the winter is a 6 mile snowshoe).
* There are hikes that I did back-to-back that I'd consider one hike but the trails might be listed separately on the site. For example, Deception Pass is actually made up of three small loops.

## Choose Packages

It took a bit to decide which packages had the functions needed to run the spatial analyses. In the end, I decided on:

* **plotKML**: A package containing functions to read GPX files
* **geosphere**: A package containing functions for geospatial calculations. I decided to use this for finding out distances between lon/lat.
* **googleway**: A package allowing access to the Google Maps API. To run this, you need to obtain a Google Maps API key and load it to R by using `set_key()`. I use this for elevation calculations but the API can also obtain distance between points.

```{r, echo = T, eval = F}
library(tidyverse)
library(googleway)
library(plotKML)
library(geosphere)

googleway::set_key(API_KEY_HERE)
```


## Data Upload

I downloaded each GPX file from AllTrails and saved them in a file in my project organization. Their file names were TRAILNAME.gpx.

* Using `plotKML::readGPX` results in the files being loaded as lists.
* I used `purrr` in conjunction with `plotKML()` to handily read them in and add the file name to the list. 

```{r, echo = T, eval = F}
# find gpx files
data_path <- 
  here::here("data", "raw", "gpx_files")

files <-
  dir(data_path, pattern = "*.gpx", full.names = TRUE)

# get trail names
names <-
  dir(data_path, pattern = "*.gpx", full.names = FALSE) %>% 
  str_extract(".+?(?=.gpx)")

# read all gpx files
gpx_dat <-
  map2(files,
       names,
       ~ readGPX(.x,
         metadata = TRUE,
         bounds = TRUE,
         waypoints = TRUE,
         tracks = TRUE,
         routes = TRUE) %>%
         list_modify(trail = .y)) # otherwise you can't tell which entry is for which trail
```


## Calculate Distance

Now we have a list of trails and longitudes and latitudes along their paths.

* We can use `map_df()` to transform the information into a dataframe.
* To use calculate distance, we can use `distHaversine()` with two sets of lon/lat. We can create the second set of lon/lat by creating a new variable that takes the "next" value in a vector (so we're calculating the distance between point A and point B, point B to point C, and so on).
* Finally, cumsum accumulates the distances between each set of lon/lat.

```{r, echo = T, eval = F}
dat_lonlat <-
  gpx_dat %>%
  map_df(., ~.x$"routes"[[1]], .id = "trail") %>%
  select(trail, lon, lat) %>% 
  group_by(trail) %>% 
  mutate(lon2 = lead(lon, 1),
         lat2 = lead(lat, 1))

dat_dist <-
  dat_lonlat %>% 
  ungroup() %>% 
  mutate(dist = distHaversine(dat_lonlat[, 2:3], dat_lonlat[, 4:5])) %>% 
  group_by(trail) %>% 
  mutate(cumdist = cumsum(dist/1609.344)) # to convert to miles

dat_dist_agg <-
  dat_dist %>% 
  group_by(trail) %>% 
  summarize(sum = sum(dist, na.rm = T))

# plot
```



